<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="hull.js"></script>
</head>
<body style="margin: 0" oncontextmenu="return false;">
  <div id="background" style="position: absolute; width: 256px; height: 256px; background-color: rgb(200, 200, 200)"></div>
  <canvas id="canvas" width="256" height="256"></canvas>
  <svg id="hullSVG">
  </svg>
</body>

<script>
(function(_exports) {
    let size = 256;
    let isPointerDown = false;
    let hullShape = null;

    let canvas = document.getElementById('canvas');
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    canvas.style.position = 'absolute';
    // canvas.style.backgroundColor = 'rgb(200, 200, 200)';
    let ctx = canvas.getContext('2d');

    let svg = document.getElementById('hullSVG');
    svg.style.width = size + 'px';
    svg.style.height = size + 'px';
    svg.style.position = 'absolute';
    // svg.style.backgroundColor = 'rgb(200, 200, 200)';
    // svg.style.opacity = '0.5';

    let rgb = {
        r: 1,
        g: 255,
        b: 252
    };
    let rgbActive = {
        r: 0,
        g: 255,
        b: 0
    };

    document.addEventListener('pointerdown', function(e) {
        // right-click to clear
        if (e.button === 2) {
            clearImage(ctx);
            clearHulls(svg);
            return;
        }

        isPointerDown = true;
        // console.log(isPointerDown);
        // clearHulls(svg);

        canvas.style.visibility = 'visible';
    });
    document.addEventListener('pointermove', function (e) {
        if (!isPointerDown) {
            updateActivity(e.clientX, e.clientY, hullShape);
            return;
        }

        drawCircle(ctx, e.clientX, e.clientY, 10, 'rgb('+rgb.r+','+rgb.g+','+rgb.b+')');

        clearHulls(svg);
        calculateConvexHull(ctx);
    });
    document.addEventListener('pointerup', function (e) {
        isPointerDown = false;
        // console.log(isPointerDown);

        calculateConvexHull(ctx);
        updateActivity(e.clientX, e.clientY, hullShape);

        canvas.style.visibility = 'hidden';
    });

    function updateActivity(x, y, hull) {
        if (!hull) { return; }

        let hullSVG = document.querySelector('.hullContents');
        let isContained = checkPoint(x, y, hull);

        if (hullSVG) {
            if (isContained) {
                // hullSVG.setAttribute("fill", 'rgba('+rgb.r+','+rgb.g+','+rgb.b+',1.0)');
                hullSVG.setAttribute("fill", 'rgba('+rgbActive.r+','+rgbActive.g+','+rgbActive.b+',0.5)');
            } else {
                hullSVG.setAttribute("fill", 'rgba('+rgb.r+','+rgb.g+','+rgb.b+',0.5)');
            }
        }
    }

    function clearImage(context) {
        context.clearRect(0, 0, size, size);
    }

    function drawCircle(context, x, y, radius, color) {
        // console.log('draw circle');
        context.fillStyle = color || 'rgb(0,0,0)'; //`#${randInt(0x1000000).toString(16).padStart(6, '0')}`;
        context.beginPath();
        context.arc(x, y, radius, 0, Math.PI * 2);
        context.fill();
    }

    function calculateConvexHull(context) {
        let image = context.getImageData(0, 0, size, size);
        let imageData = image.data;
        let tolerance = 10;
        let hullPoints = [];
        const stride = 4;
        for (let i = 0; i < imageData.length; i += stride) {
            let x = Math.floor((i % (size * stride)) / stride);
            let y = Math.floor(i / (size * stride));

            let dr = Math.abs(imageData[i] - rgb.r);
            let dg = Math.abs(imageData[i+1] - rgb.g);
            let db = Math.abs(imageData[i+2] - rgb.b);

            if (dr < tolerance && dg <= tolerance && db <= tolerance && imageData[i+3] === 255) {
                // imageData[i] = tolerance;
                // imageData[i+1] = tolerance;
                // imageData[i+2] = tolerance;
                // if (Math.random() > 0.96) {
                    // let xy = getPixelXY(i, 4, size, size);
                    hullPoints.push([x, y]);
                    // i += size;
                // }
            }
        }

        image.data = imageData;
        context.putImageData(image, 0, 0);

        // console.log(hullPoints);

        let debugPoints = false;
        if (debugPoints) {
            hullPoints.forEach(function(point) {
                drawCircle(ctx, point[0], point[1], 2, 'rgb(255, 255, 0)');
            });
        }

        drawHulls(svg, hullPoints, Infinity);
    }

    function clearHulls(svg) {
        while (svg.lastChild) {
            svg.removeChild(svg.firstChild);
        }
    }

    function drawHulls(svg, hullPoints, concavity) {
        if (hullPoints.length === 0) {
            return;
        }

        // create hull points
        hullShape = hull(hullPoints, concavity);
        var hullString = '';
        hullShape.forEach(function(pt) {
            hullString += ' ' + pt[0] + ', ' + pt[1];
        });
        hullString += ' ' + hullShape[0][0] + ', ' + hullShape[0][1];

        // draw hull
        var hullSVG = document.createElementNS(svg.namespaceURI, 'polyline');
        if (hullString.indexOf("undefined") === -1) {
            hullSVG.setAttribute("points", hullString);
            hullSVG.setAttribute("fill", 'rgba('+rgb.r+','+rgb.g+','+rgb.b+',0.5)');
            hullSVG.classList.add('hullContents');
            hullSVG.setAttribute("stroke", "#FFF");
            hullSVG.setAttribute("stroke-width", "5");
            hullSVG.classList.add("hull");
            svg.appendChild(hullSVG);
        }
    }

    function checkPoint(x, y, hull) {
        let isInAnyTriangle = false;
        let pt0 = hull[0];
        for (let i = 1; i < hull.length - 1; i++) {
            let pt1 = hull[i];
            let pt2 = hull[i+1];

            // check if x,y is within the triangle [pt0, pt1, pt2]
            if (isPointWithinTriangle(x, y, pt0[0], pt0[1], pt1[0], pt1[1], pt2[0], pt2[1])) {
                isInAnyTriangle = true;
            }
        }
        return isInAnyTriangle;
    }

    function isPointWithinTriangle(x, y, x1, y1, x2, y2, x3, y3) {
        /* Calculate area of triangle ABC */
        let A = triangleArea (x1, y1, x2, y2, x3, y3);

        /* Calculate area of triangle PBC */
        let A1 = triangleArea (x, y, x2, y2, x3, y3);

        /* Calculate area of triangle PAC */
        let A2 = triangleArea (x1, y1, x, y, x3, y3);

        /* Calculate area of triangle PAB */
        let A3 = triangleArea (x1, y1, x2, y2, x, y);

        /* Check if sum of A1, A2 and A3 is same as A */
        return (A === A1 + A2 + A3);
    }

    function triangleArea(x1, y1, x2, y2, x3, y3) {
        return Math.abs((x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))/2.0);
    }

})(window);
</script>
</html>